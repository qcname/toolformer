[
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "core_file",
    "section": "",
    "text": "source\n\nsay_hello\n\n say_hello (name:str)\n\n\n\n\n\nType\nDetails\n\n\n\n\nname\nstr\n名称\n\n\nReturns\nstr\n返回字符串\n\n\n\n\nsource\n\n\nfoo\n\n foo (a, b)\n\n\ntest_eq(foo(1,2),5)\n\n\n这是一个测试\n\nsource\n\n\n\nmse\n\n mse (y_true, y_pred)\n\n计算均方误差： \\[\n\\text{MSE} = \\frac{1}{n}\\sum_{i=1}^n (y_i - \\hat{y}_i)^2\n\\]",
    "crumbs": [
      "core_file"
    ]
  },
  {
    "objectID": "01_usage.html",
    "href": "01_usage.html",
    "title": "toolformer",
    "section": "",
    "text": "# usage\n&gt; test\n\n\n\nsource\n\nfoo1\n\n foo1 (name)",
    "crumbs": [
      "01_usage.html"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "toolformer",
    "section": "",
    "text": "This file will become your README and also the index of your documentation.",
    "crumbs": [
      "toolformer"
    ]
  },
  {
    "objectID": "index.html#developer-guide",
    "href": "index.html#developer-guide",
    "title": "toolformer",
    "section": "Developer Guide",
    "text": "Developer Guide\nIf you are new to using nbdev here are some useful pointers to get you started.\n\nInstall toolformer in Development mode\n# make sure toolformer package is installed in development mode\n$ pip install -e .\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to toolformer\n$ nbdev_prepare",
    "crumbs": [
      "toolformer"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "toolformer",
    "section": "Usage",
    "text": "Usage\n\nInstallation\nInstall latest from the GitHub repository:\n$ pip install git+https://github.com/qcname/toolformer.git\nor from conda\n$ conda install -c qcname toolformer\nor from pypi\n$ pip install toolformer\n\n\nDocumentation\nDocumentation can be found hosted on this GitHub repository’s pages. Additionally you can find package manager specific guidelines on conda and pypi respectively.",
    "crumbs": [
      "toolformer"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "toolformer",
    "section": "How to use",
    "text": "How to use\nFill me in please! Don’t forget code examples:\n\n\n\n\nName\nPosition\n\n\n\n\nChris Lattner\nInventor of Swift and LLVM\n\n\n\nFernando Pérez\nCreator of Jupyter\n\n\n\nDavid Berg\nSoftware Engineer, Netflix\n\n\n\nErik Gaasedelen\nSoftware Engineer, Lyft\n\n\n\nRoxanna Pourzand\nProduct Manager, Transform\n\n\n\nHugo Bowne-Anderson\nHead of Developer Relations, Outerbounds\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote that there are five types of callouts, including: note, warning, important, tip, and caution.",
    "crumbs": [
      "toolformer"
    ]
  },
  {
    "objectID": "usage.html",
    "href": "usage.html",
    "title": "usage",
    "section": "",
    "text": "The autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n\n\n\nsource\n\nfoo1\n\n foo1 (name)\n\n\nsource\n\n\nHelloSayer\n\n HelloSayer (to)\n\nsay_hello to someone",
    "crumbs": [
      "usage"
    ]
  },
  {
    "objectID": "00_api.html",
    "href": "00_api.html",
    "title": "toolformer",
    "section": "",
    "text": "source\n\nBaseApI\n\n BaseApI (name:str,\n          prompt_template:langchain_core.prompts.prompt.PromptTemplate,\n          sampling_threshold:float=0.2, filtering_threshold:float=0.2)\n\nInitialize self. See help(type(self)) for accurate signature.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nname\nstr\n\nthe name of API CALL\n\n\nprompt_template\nPromptTemplate\n\n\n\n\nsampling_threshold\nfloat\n0.2\n\n\n\nfiltering_threshold\nfloat\n0.2\n\n\n\n\n\nsource\n\n\nCalcuatorAPI\n\n CalcuatorAPI (name:str,\n               prompt_template:langchain_core.prompts.prompt.PromptTemplat\n               e, sampling_threshold:float=0.2,\n               filtering_threshold:float=0.2)\n\nInitialize self. See help(type(self)) for accurate signature.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nname\nstr\n\nthe name of API CALL\n\n\nprompt_template\nPromptTemplate\n\n\n\n\nsampling_threshold\nfloat\n0.2\n\n\n\nfiltering_threshold\nfloat\n0.2\n\n\n\n\n\nsource\n\n\nWolframeAPI\n\n WolframeAPI (*args, api_key:str, **kargs)\n\nInitialize self. See help(type(self)) for accurate signature.",
    "crumbs": [
      "00_api.html"
    ]
  },
  {
    "objectID": "00_data_generator.html",
    "href": "00_data_generator.html",
    "title": "toolformer",
    "section": "",
    "text": "source\n\nAugmentedCandidate\n\nsource\n\n\nDataGenerator\n\n DataGenerator (config:dict, model:Callable, tokenizer:Callable,\n                apis:List[toolformer.api.BaseApI],\n                device=device(type='cpu'))\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing to nest them in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will have their parameters converted too when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n\nivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nconfig\ndict\n\n\n\n\nmodel\ntyping.Callable\n\n\n\n\ntokenizer\ntyping.Callable\n\n\n\n\napis\ntyping.List[toolformer.api.BaseApI]\n\n\n\n\ndevice\ndevice\ncpu\ndevice: str = torch.device(“cuda” if torch.cuda.is_available() else “cpu”)",
    "crumbs": [
      "00_data_generator.html"
    ]
  },
  {
    "objectID": "00_utils.html",
    "href": "00_utils.html",
    "title": "toolformer",
    "section": "",
    "text": "source\n\nyaml2dict\n\n yaml2dict (file_path)\n\n\nsource\n\n\nextract_api_content\n\n extract_api_content (text:str, api_name:str)\n\n从给定的文本中抽取出api请求\n\nsource\n\n\nextract_api_syntax\n\n extract_api_syntax (text:str, api_name:str)\n\n抽取语法\n\nsource\n\n\nextract_api_name\n\n extract_api_name (text:str, is_end_token:bool=True)",
    "crumbs": [
      "00_utils.html"
    ]
  },
  {
    "objectID": "00_model.html",
    "href": "00_model.html",
    "title": "toolformer",
    "section": "",
    "text": "source\n\nToolFormer\n\n ToolFormer\n             (model:transformers.models.auto.modeling_auto.AutoModelForCau\n             salLM, apis:List[toolformer.api.BaseApI], config:dict)\n\n*Base class for all neural network modules.\nYour models should also subclass this class.\nModules can also contain other Modules, allowing to nest them in a tree structure. You can assign the submodules as regular attributes::\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        return F.relu(self.conv2(x))\nSubmodules assigned in this way will be registered, and will have their parameters converted too when you call :meth:to, etc.\n.. note:: As per the example above, an __init__() call to the parent class must be made before assignment on the child.\n:ivar training: Boolean represents whether this module is in training or evaluation mode. :vartype training: bool*",
    "crumbs": [
      "00_model.html"
    ]
  }
]